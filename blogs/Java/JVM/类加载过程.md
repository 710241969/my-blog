JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次

1. 编译
即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件

类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程

2. 加载
将class文件字节码内容加载到内存中，并将这些**静态数据**转换成**方法区**中的**运行时数据结构**，在**堆**中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的**访问入口**，这个过程需要**类加载器**参与
类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器
> 为什么会有自定义类加载器？
一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载
**类的加载的最终产品是位于堆区中的Class 对象**
**Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口**

3. 链接
将java类的二进制代码合并到JVM的运行状态之中的过程
* 验证：确保加载的类信息符合JVM规范，没有安全方面的问题
* 准备：正式为类变量（static变量，注意，不是实例变量）分配内存并设置类变量初始值的阶段，这些内存都将在**方法区**中进行分配
* 解析：虚拟机常量池的符号引用替换为直接引用过程
符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息
直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量
比如在方法A中使用方法B，A（）{B（）；}，这里的B（）就是符号引用，初学java时我们都是知道这是java的引用，以为B指向B方法的内存地址，但是这是不完整的，这里的B只是一个符号引用，它对于方法的调用没有太多的实际意义，可以这么认为，他就是给程序员看的一个标志，让程序员知道，这个方法可以这么调用，但是B方法实际调用时是通过一个指针指向B方法的内存地址，这个指针才是真正负责方法调用，他就是直接引用

4. 初始化
为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值
如果初始化一个类的时候，其**父类**尚未初始化，则优先初始化其父类

5. 运行
则是把编译声称的.class文件交给Java虚拟机(JVM)执行



## 双亲委派模型
1. 启动类加载器
2. 扩展类加载器
3. 应用程序类加载器
双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载
好处：保证了 Java 程序的稳定运行， Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。比如自己编写一个在类库重名的类，可以正常编译，但是不能被加载运行。
在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false


Java类加载器是Java运行时环境的一部分，负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载，即第一次使用该类时才加载
类加载器它是在虚拟机中完成的，负责动态加载Java类到Java虚拟机的内存空间中，在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例