* Java 的抽象类是啥？能 new 不能？为啥 JAVA 要有抽象类这种设计呢？这样的话，普通类不是也可以做到吗？
我：抽象继承和多态balabala（额。。。还真答不出来。。。）
（这一个问题，能够问出面试者对 Java 语言设计和机制的深入理解。区分出到底是个写业务的小程序，还是资深理解思想的大牛吧）

正确答案：
其实不是说抽象类有什么用，抽象方法和抽象类看上去是多余的，一般类确实也能满足应用。
但是现实中确实有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同，所以没有必要再父类里写。
当然你也可以把抽象类都写成非抽象类，定义一个空方法体不就行了吗，而抽象类不让创建对象，看上去只是增加了一个不必要的限制。
引入抽象方法和抽象类，是Java提供的一种语法工具，对于一些类和方法，引导使用者正确使用它们，减少被误用。
使用抽象方法，而非空方法体，子类就知道他必须要实现该方法，而不可能忽略。
使用抽象类，类的使用者创建对象的时候，就知道他必须要使用某个具体子类，而不可能误用不完整的父类。
这样别人看到你的代码，或你看到别人的代码，你就会注意抽象方法，而知道这个方法是在子类中实现的，所以，有个提示作用。
无论是写程序，还是平时做任何别的事情的时候，每个人都可能会犯错，减少错误不能只依赖人的优秀素质，还需要一些机制，使得一个普通人都容易把事情做对，而难以把事情做错。
所以总结一下，抽象类就是 Java 提供的这样一种机制，目的就是提供这种机制。

* JVM 内存划分是怎么样的？垃圾回收机制呢？新生代分为几个区？对象内存怎么移动变化的？
略。（还行，这个还是要知道的）

* 我在一个方法里定义的变量，初始化之前和之后，它在哪些内存区域里面？常量，静态变量，普通变量，基本类型，对象类型？
我：虚拟机栈，栈帧，局部变量表，方法区 balabala 。（具体的答不上）

* 我有一个类，类里的成员变量，初始化之前和之后，它又在内存的哪些区域？
我：堆，方法区 balabala 。（具体也答不上。。。）

* 垃圾回收之后内存还不够用会怎么样？
我：OOM

* 那 OOM 我放在 try catch 里面是不是就没问题了？
一开始我说是的。。。
面试官：平常没有捕获过是吧？
我：额，是的

* 那 Error 和 Exception 什么区别？
我：哦。。。 Exception 可以捕获， Error 是不行的，程序直接崩掉。。。
面试官：（点了点头）看，现在搞清楚了吧（经过 dalao 提醒，可能觉得孺子可教吧。。。）
（其实这里的回答是有问题的， Error 一样是可以被捕获的）

正确答案：
Error 和 Exception 都继承自 Throwable 类，语法上都可以被捕获。
Error 表示的是合理的应用程序不应该试图捕获的严重问题， Error 都会导致程序处于非正常的、不可恢复的状态。既然是非正常情况，所以不应该去捕获它，如 OOM
Exception 是程序正常运行中，可以预料的意外情况，应该被捕获，进行相应处理。Exception又分为可检查(checked)异常和不可检查(unchecked)异常。可检查异常在源代码里必须显式的进行捕获处理，这是编译期检查的一部分。不可检查时异常是指运行时异常，像NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求

* 那如果出现 OOM 怎么找出问题呢？
我：JVM 设置参数 -XX:+HeapDumpOnOutOfMemoryError 这样出现 OOM 会 dump 当前堆栈快照出来，就可以根据这个日志查找问题
面试官：具体参数名你可以不用说出来。那这个怎么看呢？
我：额。。。。。（不好意思真没操作过）
面试官：（笑了笑）一笔带过是吧。 java 带的几个工具没用过是吧
我： jps jstat jmap jhat jstack 。。。额，有了解但是没用过（唉。。。瓜皮选手）
面试官：好吧

* 多线程有了解吧，多线程同步你会怎么做？
我： synchronized 关键字和 ReentrantLock 同步锁都可以实现多线程对资源的同步控制

* 那，什么时候你会选用 synchronized 什么使用你用 Lock ？或者说什么时候用 Lock 会有什么好处你会获得什么性能效益上的提升？
我：额。。。 lock 可以有 condition 这是比 synchronized 更拓展的地方。。额。。。。。。。（反正没回答上来就是了）

* 写个线程安全高效的单例看看
心中窃喜，倒着我都能写得出，一下子就写完了
面试官：这是你自己写的还是参考网上的？
我：以前专门看过，自己写也会这么写，这种写法基本上这是事实性的标准吧。。没有什么网上抄的还是自己写的区别吧。。。
面试官：嗯，也是
我：当然还可以有其他的写法，比如用枚举，用静态内部类，都是很好的选择

* （接着上面我写的）那这里为什么要用 volatile 呢？
我： volatile 的两个语义一个是保证内存可见性，一个是防止指令重排序，这里都有

* 你理解的指令重排序是啥？
重排序是编译器对语句编译的一种优化，额。。。（尴尬，答非所问）

* 你说的这些只是基于变量赋值的指令重排序，如果我有一大段代码，也要防止指令重排序，怎么做到呢？
理直气壮不知道没用过。

* 你觉得你最有优势的是哪里呢？比如对哪个框架，或者哪一块编程？
我：Spring MVC 吧？（冥思苦想，如果说是多线程，抱歉现实中基本没用过。如果说是 JVM ，但我前面的问题又答不上。平时工作中也只是写写业务代码。。。真是不知道。。。Spring MCV？Spring？看过一点源码，大概知道整体流程和核心思想，但是如果要深究，其实我答不出来的啊。。。没办法，只能说 Spring 了）

* 那 Spring MVC 整个流程？从请求到响应请求？
我： balabala，记不太清楚，大致还算说得上吧

* Controller 可以返回很多格式，可以是 String ， ModelView 等等这些吧？那最后其实都转换成什么对象结构呢？
（ GG 思密达）

* IOC 里面其实就是 Bean 对吧？默认是单例是吧，假如我现在是 prototype ，那，如果我一个 A 里面有 B ， B 里面有 A ，会有问题不？为什么不会有问题？
我：balabala （瞎编的，猜的）
面试官：这只是你自己猜测的吧？回去该好好再看看

正确答案：
构造器注入 当循环依赖的bean都是通过构造器注入依赖的时候，无论这些bean是singleton还是prototype，在获取bean的时候都会失败
属性注入 当循环依赖的bean都是通过属性注入依赖的时候，根据bean的作用域是singleton还是prototpye，会有不同的表现：
如果循环依赖的bean都是singleton，那么无论先获取哪个bean，都能成功。
如果循环依赖的bean都是prototype，那么无论先获取哪个bean，都会失败。
如果循环依赖的bean中有singleton，也有prototype，那么当先获取的那个bean是singleton时，就会成功，否则失败。
如果循环依赖的bean既有构造器注入也有属性注入，既有singleton也有prototype，在容器启动后，只有当获取的第一个bean是通过属性注入依赖的singleton时，才会成功，别的情况都会失败
如果多个bean存在循环依赖，在Spring容器启动后，只有当获取的第一个bean是通过属性注入依赖的singleton时，才会成功，别的情况都会失败

* 线程通信有什么方式？
我：线程还是进程？
面试官：线程
我：um............（一下子想不起来只能瞎扯了）可以信号量 Semaphore CountDownLatch CyclicBarrier 等等。。。
面试官：（ synchronized wait notify await signal 算了吧，我就当你说的是）

* 那什么时候用 CountDownLatch？
我：其中一个线程需要等待其他线程执行完毕（还行）

* ThreadLocal 知道不？需要加同步锁保证它线程安全不？
我：了解一点。不需要加锁，是线程自己独有的变量，其他线程访问不了，所以不用加锁。肯定是线程安全的

* 那 ThreadLocal 怎么实现的呢？
我：...
面试官：回去再好好看下

* 什么数据库用得多， Oracle 用过？用了多久？
我：没有用过 Oracle 只用 MySQL ，大学时的不算，只算工作的用了一年半吧

* 一张员工表，有姓名吧？把重名的人查出来怎么写？
我： GROUP BY + HAVING
面试官：不用 GROUP BY 呢
我：（经过前面的打击，我已经紧张到无法思考， GG 一时间想不到了）

* 索引有什么用？
我：加快查询速度，像看书查目录一样，基于 B+ 树数据结构，将随机 IO 改为顺序 IO （还行）

* 那索引这么有用，加一堆上去咯？
我：不行， 索引就是个文件占用空间，而且数据的修改同时要维护索引的修改，表越大越低效率，根据具体查询加索引吧 （还行）

* 我有个字段是唯一索引，这时插入两条记录，这个字段都是 null 值，能插进去表不？
我：（犹豫了一下）可以
面试官：噢？可以？（吓唬我）
我：（其实不太确定但是我有印象的，不管了豁出去了） null 值不创建索引所以能插进去表
面试官：嗯好



面试体验：100分
两个面试官，一个很年轻的帅哥哥，一个中年的 dalao 。整体来看，是一轮非常严谨的技术面试，面试官很棒很 NICE ，对所有问题都有分寸有把握，知道哪些问题是背书的，所以整场面试就不问你任何背书问题了，都是往更深入的理解应用去问。同时，面试官都是懂得的。。。这和其他的面试不同。。。所以，还是很有含量的。
当然，对我这种瓜皮选手来说，还是回去多看看更深入的吧。。。面试官说了不止一次“回去你再看看这个”


